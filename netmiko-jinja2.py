import os
from netmiko import ConnectHandler
from jinja2 import Environment, FileSystemLoader

# --- Device Connection Details and Configuration Data ---
# Your SSH private key path
PRIVATE_KEY_FILE = os.path.expanduser("~/.ssh/admin_key")

# Define all device parameters and the specific configuration data
# they will need for Jinja2 templating.
devices = { 
    "R1-P": {
        "device_type": "cisco_ios",
        "host": "172.31.42.4",
        "username": "admin",
        "use_keys": True,
        "key_file": PRIVATE_KEY_FILE,
        "secret": "", # Leave empty if not used, or set to enable password if needed
        "config_data": { # Data passed to Jinja2 for R1
            "ospf_process_id": 1,
            "ospf_vrf": "Control-Data",
            "ospf_networks": [
                {"address": "10.42.1.0", "wildcard": "0.0.0.255", "area": 0},
                {"address": "10.42.2.0", "wildcard": "0.0.0.255", "area": 0},
            ],
            "default_information_originate": False # R1 does not originate default
        }
    },
    "R2-P": {
        "device_type": "cisco_ios",
        "host": "172.31.42.5",
        "username": "admin",
        "use_keys": True,
        "key_file": PRIVATE_KEY_FILE,
        "secret": "",
        "config_data": { # Data passed to Jinja2 for R2
            "ospf_process_id": 1,
            "ospf_vrf": "Control-Data",
            "ospf_networks": [
                {"address": "10.42.2.0", "wildcard": "0.0.0.255", "area": 0},
                {"address": "10.42.3.0", "wildcard": "0.0.0.255", "area": 0},
            ],
            "default_information_originate": True, # R2 originates default route
            "pat": { # PAT specific data
                "acl_id": 101,
                "acl_networks": [
                    {"address": "10.42.1.0", "wildcard": "0.0.0.255"},
                    {"address": "10.42.2.0", "wildcard": "0.0.0.255"},
                    {"address": "10.42.3.0", "wildcard": "0.0.0.255"},
                ],
                "inside_interfaces": ["GigabitEthernet0/1", "GigabitEthernet0/2"],
                "outside_interface": "GigabitEthernet0/3",
                "nat_vrf": "Control-Data"
            }
        }
    },
    "S1-P": {
        "device_type": "cisco_ios",
        "host": "172.31.42.3",
        "username": "admin",
        "use_keys": True,
        "key_file": PRIVATE_KEY_FILE,
        "secret": "",
        "config_data": { # Data passed to Jinja2 for S1 VLAN config
            "vlan_id": 101,
            "vlan_name": "Control_Data_Plane",
            "access_interfaces": ["GigabitEthernet0/1", "GigabitEthernet0/2"],
        }
    },
}

# --- Jinja2 Environment Setup ---
# This tells Jinja2 where to find your template files.
# 'templates' refers to the directory relative to this script.
env = Environment(loader=FileSystemLoader("templates"))

# --- Main Script Logic ---
def configure_device(device_name, config_commands):
    """
    Connects to a device using Netmiko and sends a list of configuration commands.
    """
    device_params = devices[device_name]
    # Filter out 'config_data' as it's not a Netmiko connection parameter
    netmiko_connection_params = {k: v for k, v in device_params.items() if k != "config_data"}

    net_connect = None # Initialize to None for finally block safety
    try:
        print(f"\n--- Connecting to {device_name} ({netmiko_connection_params['host']}) ---")
        net_connect = ConnectHandler(**netmiko_connection_params)
        net_connect.enable() # Enter enable mode if necessary

        print(f"Sending commands to {device_name}:")
        # Send the list of commands generated by Jinja2
        output = net_connect.send_config_set(config_commands)
        print(output)

        net_connect.save_config() # Save configuration
        print(f"--- Configuration on {device_name} complete and saved ---")
    except Exception as e:
        print(f"!!! Error configuring {device_name}: {e}")
    finally:
        if net_connect and net_connect.is_alive():
            net_connect.disconnect()

if __name__ == "__main__":
    print("Starting Netmiko configuration script with Jinja2 templating...\n")

    # --- S1-P Configuration ---
    # 1. Load the template
    s1_template = env.get_template("s1_vlan_config.j2")
    # 2. Render the template with S1's specific configuration data
    s1_config_rendered = s1_template.render(devices["S1-P"]["config_data"])
    # 3. Convert the rendered string into a list of commands for Netmiko
    s1_commands = [cmd.strip() for cmd in s1_config_rendered.splitlines() if cmd.strip()]
    # 4. Apply the configuration
    configure_device("S1-P", s1_commands)

    # --- R1-P Configuration ---
    r1_ospf_template = env.get_template("ospf_config.j2")
    r1_config_rendered = r1_ospf_template.render(devices["R1-P"]["config_data"])
    r1_commands = [cmd.strip() for cmd in r1_config_rendered.splitlines() if cmd.strip()]
    configure_device("R1-P", r1_commands)

    # --- R2-P Configuration (OSPF and PAT combined) ---
    # For R2, we have two distinct config sections that can be templated separately
    # or combined into one larger template if preferred.
    # Here, we'll render two templates and concatenate their outputs.
    r2_ospf_template = env.get_template("ospf_config.j2")
    r2_pat_template = env.get_template("r2_pat_config.j2")

    # Render OSPF part using R2's config_data
    r2_ospf_config_rendered = r2_ospf_template.render(devices["R2-P"]["config_data"])
    r2_ospf_commands = [cmd.strip() for cmd in r2_ospf_config_rendered.splitlines() if cmd.strip()]

    # Render PAT part using R2's config_data.pat (nested dictionary)
    r2_pat_config_rendered = r2_pat_template.render(devices["R2-P"]["config_data"]["pat"])
    r2_pat_commands = [cmd.strip() for cmd in r2_pat_config_rendered.splitlines() if cmd.strip()]

    # Combine all commands for R2
    r2_all_commands = r2_ospf_commands + r2_pat_commands
    configure_device("R2-P", r2_all_commands)

    print("\n--- All specified configurations attempted ---")
    print("Please verify configurations and check connectivity as per checkpoint list.")